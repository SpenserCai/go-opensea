// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// OrderV2 Models OrderV2 objects to serialize to a 'similar' schema to what we have with OrderV1s
//
// swagger:model OrderV2
type OrderV2 struct {

	// If true, the order maker has canceled the order which means it can no longer be filled.
	// Required: true
	Cancelled *bool `json:"cancelled"`

	// Date the order was closed
	// Required: true
	// Format: date-time
	ClosingDate *strfmt.DateTime `json:"closing_date"`

	// Date the order was created
	// Required: true
	// Format: date-time
	CreatedDate *strfmt.DateTime `json:"created_date"`

	// A merkle root composed of the valid set of token identifiers for the order
	// Required: true
	// Read Only: true
	CriteriaProof []string `json:"criteria_proof"`

	// Current price of the order
	// Required: true
	CurrentPrice *string `json:"current_price"`

	// Timestamp representation of closing_date
	// Required: true
	// Read Only: true
	ExpirationTime int64 `json:"expiration_time"`

	// If true, the order has already been filled.
	// Required: true
	Finalized *bool `json:"finalized"`

	// Timestamp representation of created_date
	// Required: true
	// Read Only: true
	ListingTime int64 `json:"listing_time"`

	// The unique blockchain identifier, address, of the wallet which is the order maker.
	// Required: true
	// Read Only: true
	Maker struct {
		SimpleAccount
	} `json:"maker"`

	// Deprecated Field.
	// Required: true
	// Read Only: true
	MakerAssetBundle interface{} `json:"maker_asset_bundle"`

	// maker fees
	// Required: true
	// Read Only: true
	MakerFees []*SimpleFee `json:"maker_fees"`

	// If true, the order is currently invalid and can not be filled.
	// Required: true
	// Read Only: true
	MarkedInvalid bool `json:"marked_invalid"`

	// An identifier for the order
	// Required: true
	OrderHash *string `json:"order_hash"`

	// order type
	// Required: true
	// Read Only: true
	OrderType struct {
		OrderTypeEnum
	} `json:"order_type"`

	// Exchange Contract Address. Typically the address of the Seaport contract.
	// Required: true
	// Read Only: true
	ProtocolAddress *string `json:"protocol_address"`

	// protocol data
	// Required: true
	// Read Only: true
	ProtocolData struct {
		SerializedOrder
	} `json:"protocol_data"`

	// Deprecated Field
	// Required: true
	// Read Only: true
	RelayID string `json:"relay_id"`

	// The remaining quantity of the order that has not been filled. This is useful for erc1155 orders.
	// Required: true
	RemainingQuantity *int64 `json:"remaining_quantity"`

	// The side of the order, either bid (offer) or ask(listing).
	// Required: true
	Side *string `json:"side"`

	// The unique blockchain identifier, address, of the wallet which is the order taker.
	// Required: true
	// Read Only: true
	Taker struct {
		SimpleAccount
	} `json:"taker"`

	// Deprecated Field.
	// Required: true
	// Read Only: true
	TakerAssetBundle interface{} `json:"taker_asset_bundle"`

	// taker fees
	// Required: true
	// Read Only: true
	TakerFees []*SimpleFee `json:"taker_fees"`
}

// Validate validates this order v2
func (m *OrderV2) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCancelled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClosingDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCriteriaProof(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrentPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExpirationTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFinalized(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateListingTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaker(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMakerAssetBundle(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMakerFees(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMarkedInvalid(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderHash(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocolAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocolData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRelayID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemainingQuantity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSide(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaker(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTakerAssetBundle(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTakerFees(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OrderV2) validateCancelled(formats strfmt.Registry) error {

	if err := validate.Required("cancelled", "body", m.Cancelled); err != nil {
		return err
	}

	return nil
}

func (m *OrderV2) validateClosingDate(formats strfmt.Registry) error {

	if err := validate.Required("closing_date", "body", m.ClosingDate); err != nil {
		return err
	}

	if err := validate.FormatOf("closing_date", "body", "date-time", m.ClosingDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OrderV2) validateCreatedDate(formats strfmt.Registry) error {

	if err := validate.Required("created_date", "body", m.CreatedDate); err != nil {
		return err
	}

	if err := validate.FormatOf("created_date", "body", "date-time", m.CreatedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OrderV2) validateCriteriaProof(formats strfmt.Registry) error {

	if err := validate.Required("criteria_proof", "body", m.CriteriaProof); err != nil {
		return err
	}

	return nil
}

func (m *OrderV2) validateCurrentPrice(formats strfmt.Registry) error {

	if err := validate.Required("current_price", "body", m.CurrentPrice); err != nil {
		return err
	}

	return nil
}

func (m *OrderV2) validateExpirationTime(formats strfmt.Registry) error {

	if err := validate.Required("expiration_time", "body", int64(m.ExpirationTime)); err != nil {
		return err
	}

	return nil
}

func (m *OrderV2) validateFinalized(formats strfmt.Registry) error {

	if err := validate.Required("finalized", "body", m.Finalized); err != nil {
		return err
	}

	return nil
}

func (m *OrderV2) validateListingTime(formats strfmt.Registry) error {

	if err := validate.Required("listing_time", "body", int64(m.ListingTime)); err != nil {
		return err
	}

	return nil
}

func (m *OrderV2) validateMaker(formats strfmt.Registry) error {

	return nil
}

func (m *OrderV2) validateMakerAssetBundle(formats strfmt.Registry) error {

	if m.MakerAssetBundle == nil {
		return errors.Required("maker_asset_bundle", "body", nil)
	}

	return nil
}

func (m *OrderV2) validateMakerFees(formats strfmt.Registry) error {

	if err := validate.Required("maker_fees", "body", m.MakerFees); err != nil {
		return err
	}

	for i := 0; i < len(m.MakerFees); i++ {
		if swag.IsZero(m.MakerFees[i]) { // not required
			continue
		}

		if m.MakerFees[i] != nil {
			if err := m.MakerFees[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("maker_fees" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("maker_fees" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *OrderV2) validateMarkedInvalid(formats strfmt.Registry) error {

	if err := validate.Required("marked_invalid", "body", bool(m.MarkedInvalid)); err != nil {
		return err
	}

	return nil
}

func (m *OrderV2) validateOrderHash(formats strfmt.Registry) error {

	if err := validate.Required("order_hash", "body", m.OrderHash); err != nil {
		return err
	}

	return nil
}

func (m *OrderV2) validateOrderType(formats strfmt.Registry) error {

	return nil
}

func (m *OrderV2) validateProtocolAddress(formats strfmt.Registry) error {

	if err := validate.Required("protocol_address", "body", m.ProtocolAddress); err != nil {
		return err
	}

	return nil
}

func (m *OrderV2) validateProtocolData(formats strfmt.Registry) error {

	return nil
}

func (m *OrderV2) validateRelayID(formats strfmt.Registry) error {

	if err := validate.RequiredString("relay_id", "body", m.RelayID); err != nil {
		return err
	}

	return nil
}

func (m *OrderV2) validateRemainingQuantity(formats strfmt.Registry) error {

	if err := validate.Required("remaining_quantity", "body", m.RemainingQuantity); err != nil {
		return err
	}

	return nil
}

func (m *OrderV2) validateSide(formats strfmt.Registry) error {

	if err := validate.Required("side", "body", m.Side); err != nil {
		return err
	}

	return nil
}

func (m *OrderV2) validateTaker(formats strfmt.Registry) error {

	return nil
}

func (m *OrderV2) validateTakerAssetBundle(formats strfmt.Registry) error {

	if m.TakerAssetBundle == nil {
		return errors.Required("taker_asset_bundle", "body", nil)
	}

	return nil
}

func (m *OrderV2) validateTakerFees(formats strfmt.Registry) error {

	if err := validate.Required("taker_fees", "body", m.TakerFees); err != nil {
		return err
	}

	for i := 0; i < len(m.TakerFees); i++ {
		if swag.IsZero(m.TakerFees[i]) { // not required
			continue
		}

		if m.TakerFees[i] != nil {
			if err := m.TakerFees[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taker_fees" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taker_fees" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this order v2 based on the context it is used
func (m *OrderV2) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCriteriaProof(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExpirationTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateListingTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMaker(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMakerFees(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMarkedInvalid(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOrderType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProtocolAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProtocolData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRelayID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaker(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTakerFees(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OrderV2) contextValidateCriteriaProof(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "criteria_proof", "body", []string(m.CriteriaProof)); err != nil {
		return err
	}

	return nil
}

func (m *OrderV2) contextValidateExpirationTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "expiration_time", "body", int64(m.ExpirationTime)); err != nil {
		return err
	}

	return nil
}

func (m *OrderV2) contextValidateListingTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "listing_time", "body", int64(m.ListingTime)); err != nil {
		return err
	}

	return nil
}

func (m *OrderV2) contextValidateMaker(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *OrderV2) contextValidateMakerFees(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "maker_fees", "body", []*SimpleFee(m.MakerFees)); err != nil {
		return err
	}

	for i := 0; i < len(m.MakerFees); i++ {

		if m.MakerFees[i] != nil {
			if err := m.MakerFees[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("maker_fees" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("maker_fees" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *OrderV2) contextValidateMarkedInvalid(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "marked_invalid", "body", bool(m.MarkedInvalid)); err != nil {
		return err
	}

	return nil
}

func (m *OrderV2) contextValidateOrderType(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *OrderV2) contextValidateProtocolAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "protocol_address", "body", m.ProtocolAddress); err != nil {
		return err
	}

	return nil
}

func (m *OrderV2) contextValidateProtocolData(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *OrderV2) contextValidateRelayID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "relay_id", "body", string(m.RelayID)); err != nil {
		return err
	}

	return nil
}

func (m *OrderV2) contextValidateTaker(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *OrderV2) contextValidateTakerFees(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "taker_fees", "body", []*SimpleFee(m.TakerFees)); err != nil {
		return err
	}

	for i := 0; i < len(m.TakerFees); i++ {

		if m.TakerFees[i] != nil {
			if err := m.TakerFees[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taker_fees" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taker_fees" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *OrderV2) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OrderV2) UnmarshalBinary(b []byte) error {
	var res OrderV2
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
