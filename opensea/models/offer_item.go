// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// OfferItem OfferItem
//
// swagger:model OfferItem
type OfferItem struct {

	// Endamount
	//
	// When endAmount differs from `startAmount`, the realized amount is calculated linearly based on the time elapsed since the order became active.
	// Required: true
	EndAmount *int64 `json:"endAmount"`

	// Identifierorcriteria
	//
	// The ERC721 or ERC1155 token identifier or, in the case of a criteria-based item type, a merkle root composed of the valid set of token identifiers for the item. This value will be ignored for Ether and ERC20 item types, and can optionally be zero for criteria-based item types to allow for any identifier.
	// Required: true
	IdentifierOrCriteria *int64 `json:"identifierOrCriteria"`

	// item type
	// Required: true
	ItemType *ItemType `json:"itemType"`

	// Startamount
	//
	// The amount of the token in question that will be required should the order be fulfilled.
	// Required: true
	StartAmount *int64 `json:"startAmount"`

	// Token
	//
	// The item's token contract (with the null address used for native tokens)
	// Required: true
	Token *string `json:"token"`
}

// Validate validates this offer item
func (m *OfferItem) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEndAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIdentifierOrCriteria(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateItemType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateToken(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OfferItem) validateEndAmount(formats strfmt.Registry) error {

	if err := validate.Required("endAmount", "body", m.EndAmount); err != nil {
		return err
	}

	return nil
}

func (m *OfferItem) validateIdentifierOrCriteria(formats strfmt.Registry) error {

	if err := validate.Required("identifierOrCriteria", "body", m.IdentifierOrCriteria); err != nil {
		return err
	}

	return nil
}

func (m *OfferItem) validateItemType(formats strfmt.Registry) error {

	if err := validate.Required("itemType", "body", m.ItemType); err != nil {
		return err
	}

	if err := validate.Required("itemType", "body", m.ItemType); err != nil {
		return err
	}

	if m.ItemType != nil {
		if err := m.ItemType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("itemType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("itemType")
			}
			return err
		}
	}

	return nil
}

func (m *OfferItem) validateStartAmount(formats strfmt.Registry) error {

	if err := validate.Required("startAmount", "body", m.StartAmount); err != nil {
		return err
	}

	return nil
}

func (m *OfferItem) validateToken(formats strfmt.Registry) error {

	if err := validate.Required("token", "body", m.Token); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this offer item based on the context it is used
func (m *OfferItem) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateItemType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OfferItem) contextValidateItemType(ctx context.Context, formats strfmt.Registry) error {

	if m.ItemType != nil {
		if err := m.ItemType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("itemType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("itemType")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OfferItem) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OfferItem) UnmarshalBinary(b []byte) error {
	var res OfferItem
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
