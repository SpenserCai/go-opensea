// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// OrderEventModel OrderEventModel
//
// swagger:model OrderEventModel
type OrderEventModel struct {

	// Asset
	//
	// The asset being listed or bid on. Empty object for collection or trait offers.
	// Required: true
	Asset interface{} `json:"asset"`

	// The chain on which the order was created
	// Required: true
	Chain struct {
		ChainIdentifier
	} `json:"chain"`

	// Criteria
	//
	// For collection and trait offers, this object will contain the criteria needed to fulfill the offer.
	// Required: true
	Criteria interface{} `json:"criteria"`

	// Event Type
	EventType struct {
		OrderEventModelEventTypeEnum
	} `json:"event_type,omitempty"`

	// Expiration Date
	//
	// The Posix timestamp at which the order will close. When no expiration date is set, this value will be 0.
	// Required: true
	ExpirationDate *int64 `json:"expiration_date"`

	// Maker
	//
	// Maker of the order
	// Required: true
	Maker *string `json:"maker"`

	// Order Hash
	//
	// Order hash for the newly created order
	// Required: true
	OrderHash *string `json:"order_hash"`

	// order type
	// Required: true
	OrderType OrderType `json:"order_type"`

	// Payment
	// Required: true
	Payment struct {
		EventPaymentModel
	} `json:"payment"`

	// Protocol Address
	//
	// Exchange contract address for the order
	// Required: true
	ProtocolAddress *string `json:"protocol_address"`

	// Quantity
	//
	// Number of assets in the order
	// Required: true
	Quantity *int64 `json:"quantity"`

	// Start Date
	//
	// The Posix timestamp at which the order was created
	// Required: true
	StartDate *int64 `json:"start_date"`

	// Taker
	//
	// Taker of the order. This will only be set for private listings.
	// Required: true
	Taker *string `json:"taker"`
}

// Validate validates this order event model
func (m *OrderEventModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAsset(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateChain(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCriteria(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEventType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExpirationDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaker(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderHash(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePayment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocolAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuantity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaker(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OrderEventModel) validateAsset(formats strfmt.Registry) error {

	if m.Asset == nil {
		return errors.Required("asset", "body", nil)
	}

	return nil
}

func (m *OrderEventModel) validateChain(formats strfmt.Registry) error {

	return nil
}

func (m *OrderEventModel) validateCriteria(formats strfmt.Registry) error {

	if m.Criteria == nil {
		return errors.Required("criteria", "body", nil)
	}

	return nil
}

func (m *OrderEventModel) validateEventType(formats strfmt.Registry) error {
	if swag.IsZero(m.EventType) { // not required
		return nil
	}

	return nil
}

func (m *OrderEventModel) validateExpirationDate(formats strfmt.Registry) error {

	if err := validate.Required("expiration_date", "body", m.ExpirationDate); err != nil {
		return err
	}

	return nil
}

func (m *OrderEventModel) validateMaker(formats strfmt.Registry) error {

	if err := validate.Required("maker", "body", m.Maker); err != nil {
		return err
	}

	return nil
}

func (m *OrderEventModel) validateOrderHash(formats strfmt.Registry) error {

	if err := validate.Required("order_hash", "body", m.OrderHash); err != nil {
		return err
	}

	return nil
}

func (m *OrderEventModel) validateOrderType(formats strfmt.Registry) error {

	if m.OrderType == nil {
		return errors.Required("order_type", "body", nil)
	}

	return nil
}

func (m *OrderEventModel) validatePayment(formats strfmt.Registry) error {

	return nil
}

func (m *OrderEventModel) validateProtocolAddress(formats strfmt.Registry) error {

	if err := validate.Required("protocol_address", "body", m.ProtocolAddress); err != nil {
		return err
	}

	return nil
}

func (m *OrderEventModel) validateQuantity(formats strfmt.Registry) error {

	if err := validate.Required("quantity", "body", m.Quantity); err != nil {
		return err
	}

	return nil
}

func (m *OrderEventModel) validateStartDate(formats strfmt.Registry) error {

	if err := validate.Required("start_date", "body", m.StartDate); err != nil {
		return err
	}

	return nil
}

func (m *OrderEventModel) validateTaker(formats strfmt.Registry) error {

	if err := validate.Required("taker", "body", m.Taker); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this order event model based on the context it is used
func (m *OrderEventModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEventType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePayment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OrderEventModel) contextValidateEventType(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *OrderEventModel) contextValidatePayment(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

// MarshalBinary interface implementation
func (m *OrderEventModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OrderEventModel) UnmarshalBinary(b []byte) error {
	var res OrderEventModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
