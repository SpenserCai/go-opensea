// Code generated by go-swagger; DO NOT EDIT.

package n_f_t_endpoints

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new n f t endpoints API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for n f t endpoints API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	GetAccount(params *GetAccountParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAccountOK, error)

	GetCollection(params *GetCollectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetCollectionOK, error)

	GetContract(params *GetContractParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetContractOK, error)

	GetNft(params *GetNftParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNftOK, error)

	ListCollections(params *ListCollectionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListCollectionsOK, error)

	ListNftsByAccount(params *ListNftsByAccountParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListNftsByAccountOK, error)

	ListNftsByCollection(params *ListNftsByCollectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListNftsByCollectionOK, error)

	ListNftsByContract(params *ListNftsByContractParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListNftsByContractOK, error)

	RefreshNft(params *RefreshNftParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RefreshNftOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
GetAccount gets account

Get an OpenSea Account Profile including details such as bio, social media usernames, and profile image.
*/
func (a *Client) GetAccount(params *GetAccountParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAccountOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAccountParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "get_account",
		Method:             "GET",
		PathPattern:        "/api/v2/accounts/{address}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAccountReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAccountOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for get_account: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetCollection gets a collection

Get a single collection including details such as fees, traits, and links.
*/
func (a *Client) GetCollection(params *GetCollectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetCollectionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCollectionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "get_collection",
		Method:             "GET",
		PathPattern:        "/api/v2/collections/{collection_slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetCollectionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetCollectionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for get_collection: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetContract gets contract

Get a smart contract for a given chain and address.
*/
func (a *Client) GetContract(params *GetContractParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetContractOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetContractParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "get_contract",
		Method:             "GET",
		PathPattern:        "/api/v2/chain/{chain}/contract/{address}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetContractReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetContractOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for get_contract: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNft gets an n f t

Get metadata, traits, ownership information, and rarity for a single NFT.
*/
func (a *Client) GetNft(params *GetNftParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNftOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNftParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "get_nft",
		Method:             "GET",
		PathPattern:        "/api/v2/chain/{chain}/contract/{address}/nfts/{identifier}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNftReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetNftOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for get_nft: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListCollections gets collections

Get a list of OpenSea collections.
*/
func (a *Client) ListCollections(params *ListCollectionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListCollectionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListCollectionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "list_collections",
		Method:             "GET",
		PathPattern:        "/api/v2/collections",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListCollectionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListCollectionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for list_collections: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListNftsByAccount gets n f ts by account

Get NFTs owned by a given account address.
*/
func (a *Client) ListNftsByAccount(params *ListNftsByAccountParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListNftsByAccountOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListNftsByAccountParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "list_nfts_by_account",
		Method:             "GET",
		PathPattern:        "/api/v2/chain/{chain}/account/{address}/nfts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListNftsByAccountReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListNftsByAccountOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for list_nfts_by_account: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListNftsByCollection gets n f ts by collection

Get multiple NFTs for a collection.
*/
func (a *Client) ListNftsByCollection(params *ListNftsByCollectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListNftsByCollectionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListNftsByCollectionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "list_nfts_by_collection",
		Method:             "GET",
		PathPattern:        "/api/v2/collection/{collection_slug}/nfts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListNftsByCollectionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListNftsByCollectionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for list_nfts_by_collection: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListNftsByContract gets n f ts by contract

Get multiple NFTs for a smart contract.
*/
func (a *Client) ListNftsByContract(params *ListNftsByContractParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListNftsByContractOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListNftsByContractParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "list_nfts_by_contract",
		Method:             "GET",
		PathPattern:        "/api/v2/chain/{chain}/contract/{address}/nfts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListNftsByContractReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListNftsByContractOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for list_nfts_by_contract: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RefreshNft refreshes n f t metadata

Refresh metadata for a single NFT.
*/
func (a *Client) RefreshNft(params *RefreshNftParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RefreshNftOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRefreshNftParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "refresh_nft",
		Method:             "POST",
		PathPattern:        "/api/v2/chain/{chain}/contract/{address}/nfts/{identifier}/refresh",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RefreshNftReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RefreshNftOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for refresh_nft: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
